//pref
Ambient|float|0.0|0.5|1
Diffuse|float|0.0|0.7|1
Specular|float|0.0|0.2|1
Shininess|float|1|60|120
CheckerSize|float|0.1|8|20
Blinn-Phong shading with Lambertian diffuse. Copyright 2015 Chris Rorden, BSD2clause.|note
//vert
#version 330
layout(location = 0) in vec3 Vert;
layout(location = 3) in vec3 Norm;
layout(location = 6) in vec4 Clr;
out vec3 vN, vL, vV;
out vec4 vClr, vP;
uniform mat4 ModelViewProjectionMatrix;
uniform mat4 ModelViewMatrix;
uniform mat3 NormalMatrix;
uniform vec3 LightPos = vec3(0.0, 20.0, 30.0); //LR, -DU+, -FN+
void main() {
    vN = normalize((NormalMatrix * Norm));
    vP = vec4(Vert, 1.0);
    gl_Position = ModelViewProjectionMatrix * vec4(Vert, 1.0);
    vL = normalize(LightPos);
    vV = -vec3(ModelViewMatrix*vec4(Vert,1.0));
    vClr = Clr;
}
//frag
#version 330
in vec4 vClr, vP;
in vec3 vN, vL, vV;
out vec4 color;
uniform float Ambient = 0.5;
uniform float Diffuse = 0.7;
uniform float Specular = 0.2;
uniform float Shininess = 60.0;
uniform float CheckerSize = 0.3;
uniform vec4 ClipPlane = vec4(2.0, 0.0, 0.0, 0.0);
void main() {
	if ((ClipPlane[0] < 1.5) && (dot( ClipPlane, vP) > 0.0)) discard;
	vec3 l = normalize(vL);
	vec3 n = normalize(vN);
	vec3 h = normalize(l+normalize(vV));

	vec3 offClr = vec3(0.3, 0.3, 0.3);

float halfW;
halfW = CheckerSize / 2.0;
//float halfW = CheckerSize / 2.0;
float toggle1 = mod(vP.x,CheckerSize);
float toggle2 = mod(vP.y,CheckerSize);
float toggle3 = mod(vP.z,CheckerSize);
toggle1 = step(toggle1, halfW);
toggle2 = step(toggle2, halfW);
toggle3 = step(toggle3, halfW);

float fract1 = toggle1+ toggle2 + toggle3;
fract1 = step(mod(fract1,2), 0.5);

//float fract1 = mod(vP.x,  width) / width;

fract1 = clamp(fract1, 0.0, 1.0);
//float scaled_coord_t = vP.x;
//float fract1 = clamp(scaled_coord_t / fuzz, 0.0, 1.0);
//float fract2 = clamp((scaled_coord_t - width) / fuzz, 0.0, 1.0);
//fract1 *= (1.0 - fract2);
fract1 = smoothstep(0.0, 1.0, fract1);
fract1 = fract1 * 0.5;

vec3 objClr = mix(vClr.rgb, offClr.rgb,  fract1);


	vec3 a = objClr.rgb;
	vec3 backcolor = Ambient*vec3(0.1+0.1+0.1) + a*abs(dot(n,l))*Diffuse;
	vec3 d = a * dot(n,l) * Diffuse;
	a *= Ambient;
	float s = pow(max(0.0,dot(n,h)), Shininess) * Specular;
	float backface = step(0.00, n.z);
	color = vec4(mix(backcolor.rgb, a + d + s,  backface), 1.0);
}